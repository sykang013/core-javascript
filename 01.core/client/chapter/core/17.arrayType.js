/* ---------------------------------------------------------------------- */
/* Array Type                                                             */
/* ---------------------------------------------------------------------- */

// 객체(Object) : 키(key)를 사용해 식별할 수 있는 값을 담은 집합 - `키:값의 집합`
// 배열(Array) : 순서(index)가 있는 집합 - `값의 집합`

// ※ 배열은 특별한 종류의 객체로 대괄호를 사용해 요소에 접근하는 방식은 객체 문법을 사용.
//   배열은 키(key)가 숫자(index)라는 점이 다름. 즉, 본질은 객체.
//   순서에 따른 제어가 가능하도록 다양한 메서드와 length 프로퍼티를 언어에서 제공.

// 배열 선언
let friends = "";

// 배열 요소의 총 갯수

// 배열 요소 변경

// 배열 요소 추가
let unshift;
let push;

// 배열 요소 제거
let shift;
let pop;

// 큐(queue) vs. 스택(stack)
// 큐 FIFO (먼저 들어온 것이 먼저 나간다) ← queue ←
// 스택 LIFO (나중에 들어온 것이 먼저 나간다) ↓ stack ↑

// 배열 요소 순환(loop)
// for 문, for ~ of문

// 배열 복사
let copiedArray;

// 다차원 배열
// 행렬을 저장하는 용도

const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

// 행렬의 정중앙에 위치한 요소를 찾으려면?

//[호이스팅에 관한 질문]]
//함수선언문
sayHi(); //결과값 hi!
function sayHi() {
  console.log("hi!");
  function Hello() {
    console.log("hello!");
  }
}

//함수표현식
sayBye(); //결과값 error Uncaught ReferenceError: sayBye is not defined
let expression = function sayBye() {
  console.log("bye!");
  function Hello2() {
    console.log("hello!");
  }
};
//질문) 위의 결과는  let expression이 호이스팅이 되고, sayBye 호이스팅이 되지 않기 때문? (또는 선언은 런타임 이전에 이루어지고, 값 할당은 런타임에 이루어져서?)

//질문) 호이스팅이 전역에 할당된 함수/변수에 적용되는 것인가, 아니면 자신의 스코프(?) 내에서 호이스팅이 되는 것인지? 
//+질문) 렉시컬이란 도대체 무엇인가... 

질문이 좋네요
위의 결과가 일반 함수 선언문이고
밑에가 함수 표현식 //에러가 나는 이유는  선언문 자체는 함수가 통째로 실행컨텍스트 안으로 들어가서. 언제어디서든지 세이하이를 할수 있는 반면<div className=""></div>
//let 과 const는 TDZ, 함수가 참조되지 않기 때문에. 
//세비바이를 만나기 전까진 실행이 안될것이다. 모듈 프로그래밍 진행하면 (또는 선언은 런타임 이전에 초기값으로 이루어지고, 값 할당은 런타임에 이루어져서?으로 그 줄 ㅇ )
//전역에서만 자신의 실행컨텍스트가 있기 ㄷ때문에. 실행 컨텍스트 
//렉시컬 인바리어먼트. 렉시컬. 단어를 풀어보면 어휘적 환경이라 한다. 말로 주고받는 환경이 생기고 이런건 물리적으로 눈에 보이지 않는다. 눈으로 볼 수 없는 환경...말로는 표현이 가능한... 
//말로 표현이 가능한. 인간이 이해하기 위한. 그 상황을 이해시켜야 하기 console.error('때문에..',때문에..)

//데이터 불변성... 모듈 프로그래밍이 들어가게 되면 파일 단위로 모듈화가 되어서 거기서 일반함수를 선언하건 표현식을 선언하건 상관 없으므로. 모듈프로그래밍 하면 


//
//1. 범쌤이 전역에 선언한 함수 선언문은 window 객체 메서드로 바인딩 되는데 {}씌워지면 전역지역에서 호출이 불가능하다고 하지 않으셨나요?
//=>된다고 한다. 블록 스코프 안에 함수가 있으면 이거도 전역으로 들어가진다. 함수가 함수 안에 있으면 상위 컨텍스트 참조하는 것으로. (혹시몰라 유즈 스트릭트를 써봤는데 똑같이 작동)
//2. {} 스코프는 실행컨택스트 스택에 쌓이는 depth를 구분으로 Environment Record에 기록?
//3. 왜  전역에 선언한 함수는 함수 실행 컨텍스트가 생성되지 않고, Global 실행 컨텍스트가 생성,, 조금 헷갈리네요
//=>전역에 생성한 함수 자체는 전역으로 들어가지는데 그 안에서의 실행 컨텍스트가 또 생성이 되는 것이다. 선언 자체는 전역에 올라가고. 실행하게 되면 전역 컨텍스트에서 돌아가는게 아니라 함수 자체의 컨텍스트가 생기는것. 
//선언과 실행, 선언과 할당은 분리되서 얘기해야한다.
//이런 표현식은 이 값을 내보냅니다. 이런것들을 계속 내보내는 애들과 내보내는 애들을 계속 비교를 해야한다. 자스 중급자가 되면 새로운 기능들을 보면 그래서 얘는 뭘 내보내는데? 하고 찾게 된다. 
//안내보내면 뭘 처리하는데"? 내보내면 무슨 값을 처리하는데? 일케. 






//함수선언2
sayWow(); //결과값 Wow!
let wow = function sayWow() {
  console.log("Wow!");
  function Hello2() {
    console.log("hello!");
  }
};
