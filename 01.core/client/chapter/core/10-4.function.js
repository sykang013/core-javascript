/* ---------------------------------------------------------------------- */
/* Functions → Recursion                                                  */
/* ---------------------------------------------------------------------- */

// 재귀(Recursion)
// 사전적 정의: "본래 있던 곳으로 다시 돌아옴"
// 프로그래밍 정의:
// - "문제 해결을 위해 함수 자신을 다시 호출"
// - "어떤 프로시저(절차)가 자기 자신을 반복적 호출하여 문제를 풀어 나가는 알고리즘"

// -----------------------------------------------------------------------

// pow 함수를 재귀 호출 방식으로 변경
// - 재귀 기반(base) : 재귀를 언제 멈출 것인가?
// - 재귀 단계(step) : 재귀 시, 반복적으로 처리할 일(공통적인 처리))
// - 재귀 깊이(depth)재귀를 최대 몇 번 수행할 것임?

//재귀를 이해할 때는 일반함수처럼 (순차적으로) 이해하면 안된다.
//재귀함수는 함수를 실행한 곳부터 이해해야 한다. (함수 내부에 중첩 호출이 있을 때는 함수의 싱행이 일시중지 되기 때문에. )
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n, -1);
  }
}
pow(2, 4);

// factorial 함수를 재귀 호출 방식으로 작성
// 참고: https://bit.ly/factorial-util
// - 팩토리얼 = 그 수보다 작거나 같은 모든 양의 정수의 곱
// - 기호(!)를 사용하여 n!으로 표기
// - 예시) 4! = 4 * 3 * 2 * 1

//인수에 4를 넣으면 if식이 false이므로 일시정지가 되고
function factorial(n) {
  if (n === 1) {
    return n;
  } else {
    //밑의 계산이 죽죽 쌓이다가(퍼스트 인 라스트 아웃) 멈춰지면 다시 위부터 계산
    return n * factorial(n - 1);
  }
}

// fibonacci 함수를 재귀 호출 방식으로 작성
// 참고: https://bit.ly/fibonacci-util
// - 피보나치 수 = 처음과 두번째 항은 1이고, 그 뒤 모든 항은 바로 앞 두 항을 더한 합인 수열
// 예시) 1, 1, 2, 3, 5, 8, ...

function fibonacci(n) {
  //아래코드는 거짓이라 실행되지 않음
  if (n <= 0) return 0;
  //아래코드는 거짓이라 실행되지 않음
  if (n <= 2) return 1;
  //어려워 보이지만 밑에 있는 것은 위키백과에서 가져온 보나치 수열 :
  //이 식을 계산하기 전에 멈춘다. 함수가 먼저 실행되기 때문에.
  //나 자신을 호출한 순간 계산하지 않고 멈춰서 스택에 차곡차곡 쌓이다. 그러다 더이상 실행할 게 없을때 거기에 리턴값이 있으면
  //그 리턴값을 받아서 실행하고 그 리턴값을 받아서 밑에 애가 실행하고 이렇게. 가는 애이다.
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// -----------------------------------------------------------------------

// 실행 컨텍스트(execusion context)의 작동 흐름
// - 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조
// - 제어 흐름의 현재 위치, 변수의 현재 값, this 등 저장
// - 함수가 호출될 때 마다, 하나의 실행 컨텍스트 생성
// - 내부에 중첩된 함수를 포함한 경우
//   - 현재 함수의 실행 일시 중지
//   - 중지된 함수와 연관된 실행 컨텍스트는 "실행 컨텍스트 스택" 자료 구조에 저장 됨
//   - 중첩 함수가 호출되어 실행 됨 (호출 시 새로운 컨텍스트 생성)
//   - 중첩 호출 실행이 종료되면 실행 컨텍스트 스택에서 일시 중단된 함수 실행 컨텍스트 꺼냄(pop)
//   - 다시 중단되었던 함수의 실행을 이어감

// -----------------------------------------------------------------------

// 반복문 기반 알고리즘 vs. 재귀 호출 알고리즘
// - 재귀 호출 알고리즘은 재귀 깊이만큼 메모리가 필요
// - 반복문 기반 알고리즘은 메모리가 절약 됨
////재귀로 만들 수 있는 것은 반복문으로도 만들 수 있다.
////재귀로 할 수 있는 것은 안에 반복문이나 for문을 넣으면 다 할 수 있음.
////그러면 성능적인 측면에서는 반복문이 좋은데, 재귀는 왜 쓰냐?
////재귀를 쓰는 이유는 가독성이 좋기 때문이다. (나중에라도 훨씬 보기가 편하고, 보기가 편한것이 유지보수가 편한 것이다.)

// 요약
// - 메모리 최적화 관점에서는 반복문 기반 알고리즘에 비해 메모리 사용도가 높은 점이 약점
// - 작성하는 모든 곳에서 메모리 최적화가 필요한 것은 아니므로 가독성을 높이는 코드가 필요
// - 재귀는 코드를 짧게 만들고, 코드 이해도를 높이며 유지보수에도 이점이 있어 많이 사용됨

// -----------------------------------------------------------------------

// 메모이제이션(메모리 최적화를 위한)을 사용한 fibonacci 함수를 작성해보세요.
////메모이제이션은 패턴처럼 활용이 많이 된다. (특히 React에서)
////메모이제이션 패턴: 어딘가 저장소를 만들어두고 거기다가 값을 저장해두는
// 참고: https://bit.ly/memoiz
// - 동일 계산 반복 시, 이전 계산 값을 메모리에 저장하여 실행 속도를 높이는 방법

const memoFibo = (n) => {
  if (n <= 0) return 0;
  if (n <= 2) return 1;
  //내가 이미 계산한 값이 있으면 그걸 memoFibo.chache에 넣으면 여기서 다 걸러진다는 것이다.
  //값이 있으면 너가 있는거 가져다 쓰고, 값이 없으면 계산을 해.
  if (memoFibo.cache[n]) {
    return memoFibo.cache[n];
  } else {
    return (memoFibo.cache[n] = memoFibo(n - 1) + memoFibo(n - 2));
  }
};

//어떤 값을 캐시할 수 있는 공간도 필요할 것.
//자바스크립트의 펑션은 찐오브젝트의 능력이므로, 모든 펑션은 찐오브젝트의 능력을 다 쓸 수 있다.
//전역이 오염되지 않게 하기 위해(?) 사용가능한 곳은 memo.Fibo로 제한. :맞다고 하심
//cache는 그냥 빈 객체를 만들어서 이름 붙인거. 다른이름 붙여도 됨.
memoFibo.cache = {};
//근데 난 왜 콘솔에서 실행이 안되지 ㅠ

// -----------------------------------------------------------------------

// 회사 부서 팀원들의 월급 총 합을 구해보세요.
// - 반복문 기반 또는 재귀 호출 알고리즘 중 택 1
////Object.values와
////reduce를 알고있어야 문제풀이 가능할것.

const SocialPartiners = {
  foundingDate: 2021,
  team: {
    marketing: [
      {
        name: "이진아",
        salary: 3_250_000,
      },
      {
        name: "박연성",
        salary: 2_600_000,
      },
    ],
    design: {
      ui: [
        {
          name: "송우진",
          salary: 3_920_000,
        },
        {
          name: "김지평",
          salary: 2_743_000,
        },
      ],
      uxd: [
        {
          name: "이수아",
          salary: 4_000_000,
        },
        {
          name: "최철상",
          salary: 3_208_000,
        },
        {
          name: "고요미",
          salary: 2_106_000,
        },
      ],
    },
  },
};
